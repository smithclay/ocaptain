#!/usr/bin/env bash
# ==============================================================================
# ocaptain - Lightweight Multi-Agent Control Plane
# ==============================================================================
#
# Version: 0.1.0
# Repository: https://github.com/smithclay/ocaptain
# License: MIT
#
# A nautical-themed fleet management system for exe.dev VMs, orchestrating
# coding agents across a distributed fleet of ships commanded by a flagship.
#
# Compatibility:
#   - Bash 4.0+ (arrays, associative features)
#   - macOS (BSD utilities) and Linux (GNU utilities)
#   - Requires: ssh, jq, scp, openssl
#
# Usage:
#   ./ocaptain help              Show available commands
#   source ./ocaptain            Source for testing (functions only)
#
# ==============================================================================

set -euo pipefail

# Source detection for testing frameworks (Bats, etc.)
# When sourced, functions are available but main() doesn't execute
[[ "${BASH_SOURCE[0]}" != "${0}" ]] && OCAP_SOURCED=true || OCAP_SOURCED=false

# ==============================================================================
# SECTION: CONSTANTS & CONFIGURATION
# Description: Readonly values and environment configuration
# ==============================================================================

readonly OCAP_VERSION="0.1.0"
readonly OCAP_CONFIG_DIR="$HOME/.ocaptain"
readonly OCAP_CONFIG_FILE="$OCAP_CONFIG_DIR/config.json"
readonly OCAP_IDENTITY_FILE="$OCAP_CONFIG_DIR/identity.json"
readonly OCAP_VM_PREFIX_SHIP="ship"
readonly OCAP_VM_PREFIX_FLAGSHIP="flagship"

# Script directory (for .env loading and self-deployment)
OCAP_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load .env if present (shell-compatible)
if [[ -f "$OCAP_SCRIPT_DIR/.env" ]]; then
  set -a
  # shellcheck disable=SC1090,SC1091
  . "$OCAP_SCRIPT_DIR/.env"
  set +a
fi

# Default command timeout: 5 minutes
readonly OCAP_CMD_TIMEOUT_S="${CMD_TIMEOUT_S:-300}"

# ==============================================================================
# SECTION: CORE UTILITIES
# Description: Pure functions with no side effects, suitable for unit testing
# ==============================================================================

# Log a message to stderr with prefix
_ocap_log() {
  printf '==> %s\n' "$*" >&2
}

# Log an error and exit
_ocap_die() {
  printf 'ERROR: %s\n' "$*" >&2
  exit 1
}

# Check if a command exists
_ocap_need_cmd() {
  command -v "$1" >/dev/null 2>&1 || _ocap_die "Missing required command: $1"
}

# Generate a UUID (portable across Linux/macOS)
_ocap_uuid_gen() {
  uuidgen 2>/dev/null || cat /proc/sys/kernel/random/uuid
}

# Shell-escape a value for safe embedding in SSH commands
_ocap_shell_quote() {
  printf '%q' "$1"
}

# Portable base64 decode (works on both Linux and macOS)
_ocap_base64_decode() {
  openssl base64 -d -A
}

# Generate a unique ship ID from repo/project name
# Pure function: takes name, outputs ID with random suffix
_ocap_generate_ship_id() {
  local name="$1"
  local suffix
  suffix=$(openssl rand -hex 3)  # 6 chars
  echo "${name}-${suffix}"
}

# Get current namespace (default: "default")
_ocap_ns() {
  echo "${OCAP_NS:-default}"
}

# Get namespace root directory
_ocap_ns_root() {
  echo "$OCAP_CONFIG_DIR/ns/$(_ocap_ns)"
}

# Get path to ships registry JSON
_ocap_ships_json() {
  echo "$(_ocap_ns_root)/ships.json"
}

# Get path to artifacts directory
_ocap_artifacts_root() {
  echo "$(_ocap_ns_root)/artifacts"
}

# Get current role from identity file
_ocap_get_role() {
  jq -r '.role // "local"' "$OCAP_IDENTITY_FILE" 2>/dev/null || echo "local"
}

# Check if current role is in allowed list
_ocap_require_role() {
  local allowed=("$@")
  local current
  current=$(_ocap_get_role)
  for role in "${allowed[@]}"; do
    [[ "$current" == "$role" ]] && return 0
  done
  _ocap_die "Command not available for role '$current'. Allowed: ${allowed[*]}"
}

# ==============================================================================
# SECTION: PURE DATA FUNCTIONS
# Description: Functions that operate on data without side effects (testable)
# ==============================================================================

# Filter ships from VM list by prefix (pure function)
# Input: prefix, vms_json (from exe.dev ls)
# Output: matching ship IDs (one per line)
_ocap_filter_ships_by_prefix() {
  local prefix="$1" vms_json="$2"
  printf '%s' "$vms_json" | jq -r --arg prefix "$prefix" '
    .[] | select(.vm_name | startswith("ship-")) |
    .vm_name | ltrimstr("ship-") |
    select(startswith($prefix))
  '
}

# Format fleet status as JSON (pure function)
# Input: hostname, vms_json, registry_json
# Output: JSON object with flagship and ships
_ocap_format_fleet_status_json() {
  local hostname="$1" vms_json="$2" registry_json="$3"

  printf '%s' "$vms_json" | jq -c --arg flagship "$hostname" --argjson reg "$registry_json" '
    {
      flagship: $flagship,
      ships: [
        .[] | select(.vm_name | startswith("ship-")) |
        (.vm_name | ltrimstr("ship-")) as $id |
        {
          id: $id,
          repo: ($reg[$id].repo // null),
          ssh_dest: .ssh_dest,
          status: .status
        }
      ] | sort_by(.id)
    }
  '
}

# Format fleet status output (pure function)
# Input: hostname, vms_json, registry_json
# Output: formatted status text
_ocap_format_fleet_status() {
  local hostname="$1" vms_json="$2" registry_json="$3"

  echo "FLAGSHIP: $hostname"
  echo ""

  local ships_data
  ships_data=$(printf '%s' "$vms_json" | jq -r --argjson reg "$registry_json" '
    .[] | select(.vm_name | startswith("ship-")) |
    (.vm_name | ltrimstr("ship-")) as $id |
    [$id, ($reg[$id].repo // "-"), .ssh_dest, .status]
    | @tsv
  ' 2>/dev/null | sort)

  if [[ -z "$ships_data" ]]; then
    echo "SHIPS: (none)"
  else
    local ship_count
    ship_count=$(echo "$ships_data" | grep -c . || echo 0)

    echo "SHIPS ($ship_count):"
    {
      echo "SHIP	REPO	SSH_DEST	STATUS"
      echo "$ships_data"
    } | column -t -s $'\t' | sed 's/^/  /'
  fi
}

# ==============================================================================
# SECTION: INFRASTRUCTURE HELPERS
# Description: SSH, NATS, and exe.dev interaction (side-effectful)
# ==============================================================================

# Get live VM state from exe.dev
_ocap_exe_dev_ls() {
  ssh exe.dev ls -json 2>/dev/null | jq -c '.vms // []'
}

# NATS publish helper
_ocap_nats_pub() {
  local subject="$1" data="$2"
  nats pub "$subject" "$data" 2>/dev/null
}

# NATS request helper (with timeout)
_ocap_nats_req() {
  local subject="$1" data="$2" timeout="${3:-300s}"
  nats req "$subject" "$data" --timeout "$timeout" --raw 2>/dev/null
}

# NATS subscribe helper
_ocap_nats_sub() {
  local subject="$1"
  nats sub "$subject" --raw
}

# Check if flagship is configured
_ocap_need_flagship() {
  [[ -f "$OCAP_CONFIG_FILE" ]] || _ocap_die "No flagship configured. Run: ocaptain init"
}

# Get flagship SSH destination
_ocap_flagship() {
  jq -r '.flagship' "$OCAP_CONFIG_FILE"
}

# Execute command on flagship via SSH
_ocap_flagship_ssh() {
  ssh -A "$(_ocap_flagship)" "$@"
}

# Wait for SSH to become available
_ocap_wait_for_ssh() {
  local dest="$1"
  local retries="${2:-60}"
  local delay="${3:-2}"
  local opts='-o StrictHostKeyChecking=accept-new -o BatchMode=yes -o ConnectTimeout=5'

  for ((i=1; i<=retries; i++)); do
    # shellcheck disable=SC2086  # opts needs word splitting
    if ssh $opts "$dest" 'true' >/dev/null 2>&1; then
      return 0
    fi
    _ocap_log "SSH not ready ($i/$retries)..."
    sleep "$delay"
  done
  return 1
}

# Deploy ocaptain script to remote host
_ocap_deploy_script() {
  local dest="$1"
  local src="${2:-$OCAP_SCRIPT_DIR/ocaptain}"
  ssh "$dest" 'mkdir -p ~/.local/bin'
  scp -q "$src" "${dest}:\$HOME/.local/bin/ocaptain"
  ssh "$dest" 'chmod +x \$HOME/.local/bin/ocaptain'
}

# Upload init script to remote (returns env var for remote use)
_ocap_upload_init_script() {
  local dest="$1"
  if [[ -n "${INIT_PATH:-}" ]]; then
    [[ -f "$INIT_PATH" ]] || _ocap_die "INIT_PATH file not found: $INIT_PATH"
    _ocap_log "Uploading local init script..."
    scp -q "$INIT_PATH" "${dest}:~/.local/bin/init.sh"
    ssh "$dest" 'chmod +x ~/.local/bin/init.sh'
    echo "INIT_PATH=~/.local/bin/init.sh"
  else
    local url="${INIT_URL:-https://raw.githubusercontent.com/smithclay/ocaptain/main/cloudinit/init.sh}"
    echo "INIT_URL=$(printf %q "$url")"
  fi
}

# Upload dotfiles to remote (returns env var for remote use)
_ocap_upload_dotfiles() {
  local dest="$1"
  if [[ -n "${DOTFILES_PATH:-}" ]]; then
    [[ -d "$DOTFILES_PATH" ]] || _ocap_die "DOTFILES_PATH directory not found: $DOTFILES_PATH"
    _ocap_log "Uploading local dotfiles..."
    ssh "$dest" "rm -rf ~/.dotfiles"
    scp -rq "$DOTFILES_PATH" "${dest}:~/.dotfiles"
    echo "DOTFILES_PATH=~/.dotfiles"
  elif [[ -n "${DOTFILES_URL:-}" ]]; then
    echo "DOTFILES_URL=$(printf %q "$DOTFILES_URL")"
  fi
}

# Run init script with appropriate environment
_ocap_run_init_script() {
  local role="$1"
  shift
  # Remaining args are extra env vars in KEY=value format
  local env_cmd=(env "GH_TOKEN=${GH_TOKEN:-}" "ROLE=$role" "DOTFILES_PATH=${DOTFILES_PATH:-}" "DOTFILES_URL=${DOTFILES_URL:-}" "$@")
  if [[ -n "${INIT_PATH:-}" ]]; then
    _ocap_log "Running OS init script (local)..."
    "${env_cmd[@]}" bash "$INIT_PATH"
  elif [[ -n "${INIT_URL:-}" ]]; then
    _ocap_log "Running OS init script (remote)..."
    curl -fsSL "$INIT_URL" | "${env_cmd[@]}" bash
  fi
}

# Remove a VM from exe.dev
_ocap_remove_exe_vm() {
  local vm="$1" label="${2:-Removing}"
  _ocap_log "$label $vm..."
  timeout 30 ssh -n exe.dev rm "$vm" 2>/dev/null || _ocap_log "Warning: Failed to remove $vm"
}

# ==============================================================================
# SECTION: BUSINESS LOGIC
# Description: Ship and fleet operations, registry management
# ==============================================================================

# Initialize ships registry file
_ocap_init_ships_registry() {
  local file
  file="$(_ocap_ships_json)"
  mkdir -p "$(dirname "$file")"
  [[ -f "$file" ]] || echo '{}' > "$file"
}

# Register a ship in the registry
_ocap_register_ship() {
  local ship_id="$1" repo="$2"
  local file
  file="$(_ocap_ships_json)"
  local tmp="${file}.tmp"
  jq --arg id "$ship_id" --arg repo "$repo" '.[$id] = {repo: $repo}' "$file" > "$tmp" && mv "$tmp" "$file"
}

# Remove a ship from the registry
_ocap_delete_ship() {
  local ship_id="$1"
  local file
  file="$(_ocap_ships_json)"
  local tmp="${file}.tmp"
  jq --arg id "$ship_id" 'del(.[$id])' "$file" > "$tmp" && mv "$tmp" "$file"
}

# Resolve ship prefix to full ship ID (side-effectful: fetches VM list)
_ocap_resolve_ship_prefix() {
  local prefix="$1"
  local vms matches

  vms=$(_ocap_exe_dev_ls)
  matches=$(_ocap_filter_ships_by_prefix "$prefix" "$vms")

  local count
  count=$(echo "$matches" | grep -c . || echo 0)

  case "$count" in
    0) _ocap_die "No ship matches '$prefix'" ;;
    1) echo "$matches" ;;
    *) _ocap_die "Multiple ships match '$prefix': $(echo "$matches" | tr '\n' ' ')" ;;
  esac
}

# Get ssh_dest for a ship ID from exe.dev ls
_ocap_lookup_ship_ssh_dest() {
  local ship_id="$1"
  local vm_name="${OCAP_VM_PREFIX_SHIP}-${ship_id}"

  _ocap_exe_dev_ls | jq -r --arg vm "$vm_name" '.[] | select(.vm_name == $vm) | .ssh_dest'
}

# Shared VM creation helper - creates VM, waits for SSH, deploys ocaptain
# Usage: ssh_dest=$(_ocap_create_vm "vm-name")
# Outputs ssh_dest to stdout, logs to stderr
_ocap_create_vm() {
  local vm_name="$1"

  _ocap_log "Creating VM ($vm_name)..."
  local create_json
  create_json=$(ssh exe.dev new --json --name="$vm_name" --no-email) \
    || _ocap_die "Failed to create VM"

  local ssh_dest
  ssh_dest=$(echo "$create_json" | jq -r '.ssh_dest // empty')
  [[ -n "$ssh_dest" ]] || _ocap_die "Failed to get ssh_dest from: $create_json"

  _ocap_log "VM created: $ssh_dest"

  _ocap_wait_for_ssh "$ssh_dest" || _ocap_die "SSH never became ready for $ssh_dest"

  _ocap_log "Deploying ocaptain..."
  ssh -o StrictHostKeyChecking=accept-new "$ssh_dest" 'true' 2>/dev/null  # Accept host key
  _ocap_deploy_script "$ssh_dest"

  _ocap_log "Uploading init script and dotfiles..."
  local init_env dotfiles_env
  init_env=$(_ocap_upload_init_script "$ssh_dest")
  dotfiles_env=$(_ocap_upload_dotfiles "$ssh_dest")

  # Return ssh_dest and env vars via stdout (caller captures)
  echo "$ssh_dest"
  echo "$init_env"
  echo "$dotfiles_env"
}

# Confirmation prompt for destructive operations
_ocap_confirm_sink() {
  local force="$1"
  [[ "$force" == true ]] && return 0
  echo ""
  printf "Type 'sink' to confirm: "
  read -r confirm
  [[ "$confirm" == "sink" ]] || _ocap_die "Aborted."
}

# Implementation: fleet status (runs on flagship)
# Args: [--json]
_ocap_fleet_status_impl() {
  local format="text"
  [[ "${1:-}" == "--json" ]] && format="json"

  local hostname vms registry
  hostname=$(hostname -f 2>/dev/null || hostname)
  vms=$(_ocap_exe_dev_ls)
  registry=$(cat "$(_ocap_ships_json)" 2>/dev/null || echo '{}')

  if [[ "$format" == "json" ]]; then
    _ocap_format_fleet_status_json "$hostname" "$vms" "$registry"
  else
    _ocap_format_fleet_status "$hostname" "$vms" "$registry"
  fi
}

# Implementation: create ship (runs on flagship)
_ocap_ship_create_impl() {
  local arg="$1"
  local repo="" name=""

  # Determine if arg is a repo (contains /) or just a name
  if [[ "$arg" == */* ]]; then
    repo="$arg"
    name="${repo##*/}"
    _ocap_log "Validating repo '$repo' exists..."
    gh repo view "$repo" --json nameWithOwner >/dev/null 2>&1 \
      || _ocap_die "Repository '$repo' not found or not accessible with current token"
    _ocap_log "Repo validated: $repo"
  else
    name="$arg"
    _ocap_log "Creating empty ship '$name' (no repo)"
  fi

  local ship_id
  ship_id=$(_ocap_generate_ship_id "$name")

  # Get fleet SSH key
  _ocap_log "Using fleet SSH key..."
  local privkey_b64 pubkey_b64
  privkey_b64=$(base64 < ~/.ssh/id_ed25519 | tr -d '\n')
  pubkey_b64=$(base64 < ~/.ssh/id_ed25519.pub | tr -d '\n')

  # Create VM
  local vm_output ssh_dest init_env dotfiles_env
  vm_output=$(_ocap_create_vm "${OCAP_VM_PREFIX_SHIP}-${ship_id}")
  ssh_dest=$(echo "$vm_output" | sed -n '1p')
  init_env=$(echo "$vm_output" | sed -n '2p')
  dotfiles_env=$(echo "$vm_output" | sed -n '3p')

  _ocap_log "Registering ship..."
  _ocap_register_ship "$ship_id" "$repo"

  # Build init environment
  _ocap_log "Running captain init on ship..."
  local flagship_host init_args
  flagship_host="exedev@$(hostname -f 2>/dev/null || hostname)"

  init_args="$init_env $dotfiles_env"
  init_args="$init_args FLAGSHIP_SSH_DEST=$(printf %q "$flagship_host")"
  init_args="$init_args SHIP_ID=$(printf %q "$ship_id")"
  init_args="$init_args SHIP_SSH_PRIVKEY_B64=$(printf %q "$privkey_b64")"
  init_args="$init_args SHIP_SSH_PUBKEY_B64=$(printf %q "$pubkey_b64")"
  [[ -n "${GH_TOKEN:-}" && -n "$repo" ]] && init_args="GH_TOKEN=$(printf %q "$GH_TOKEN") $init_args"

  # shellcheck disable=SC2029  # Intentional client-side expansion
  ssh "$ssh_dest" "$init_args \$HOME/.local/bin/ocaptain _init_captain $(printf %q "$repo")"

  _ocap_log "Created ship: $ship_id"
}

# Implementation: destroy ship (runs on flagship)
_ocap_ship_destroy_impl() {
  local prefix="$1"
  local ship_id
  ship_id=$(_ocap_resolve_ship_prefix "$prefix")

  _ocap_remove_exe_vm "${OCAP_VM_PREFIX_SHIP}-${ship_id}"
  _ocap_delete_ship "$ship_id"

  _ocap_log "Ship '$ship_id' destroyed."
}

# Implementation: resolve ship prefix to ssh_dest (runs on flagship)
_ocap_ship_resolve() {
  local prefix="$1"
  [[ -n "$prefix" ]] || _ocap_die "Usage: _ship_resolve <prefix>"

  local ship_id ssh_dest
  ship_id=$(_ocap_resolve_ship_prefix "$prefix")
  ssh_dest=$(_ocap_lookup_ship_ssh_dest "$ship_id") || _ocap_die "Ship '$ship_id' has no ssh_dest"
  echo "$ssh_dest"
}

# Implementation: direct fleet sink (bypasses flagship)
_ocap_fleet_sink_direct() {
  local force="$1" scuttle="$2"
  _ocap_log "Direct cleanup mode: bypassing flagship..."

  local all_vms ship_vms flagship_vms
  all_vms=$(ssh exe.dev ls 2>/dev/null | grep -oE '(flagship|ship)-[a-zA-Z0-9_-]+' || true)
  ship_vms=$(echo "$all_vms" | grep -E '^ship-' || true)
  flagship_vms=$(echo "$all_vms" | grep -E '^flagship-' || true)

  if [[ -z "$ship_vms" && ( -z "$flagship_vms" || "$scuttle" != true ) ]]; then
    _ocap_log "No ocaptain VMs to remove"
  else
    echo "VMs to remove:"
    [[ -n "$ship_vms" ]] && echo "$ship_vms" | while read -r vm; do [[ -n "$vm" ]] && echo "  - $vm"; done
    [[ -n "$flagship_vms" && "$scuttle" == true ]] && echo "$flagship_vms" | while read -r vm; do [[ -n "$vm" ]] && echo "  - $vm"; done

    _ocap_confirm_sink "$force"

    [[ -n "$ship_vms" ]] && echo "$ship_vms" | while read -r vm; do [[ -n "$vm" ]] && _ocap_remove_exe_vm "$vm"; done
    [[ -n "$flagship_vms" && "$scuttle" == true ]] && echo "$flagship_vms" | while read -r vm; do [[ -n "$vm" ]] && _ocap_remove_exe_vm "$vm" "Scuttling"; done
  fi

  [[ -d "$OCAP_CONFIG_DIR" ]] && { _ocap_log "Removing local config..."; rm -rf "$OCAP_CONFIG_DIR"; }
  _ocap_log "Direct cleanup complete."
}

# Inbox: send a command to a recipient
_ocap_inbox_send() {
  [[ $# -ge 2 ]] || _ocap_die "Usage: ocaptain inbox send <recipient> <command>"
  local recipient="$1"
  local command="$2"

  local subject request_id payload

  if echo "$recipient" | grep -qE '^captain@.+$'; then
    subject="ocap.cmd.${recipient#captain@}"
  elif [[ "$recipient" == "commodore@flagship" ]]; then
    subject="ocap.cmd.commodore"
  else
    _ocap_die "Invalid recipient format. Use captain@<ship-id> or commodore@flagship"
  fi

  request_id=$(_ocap_uuid_gen)
  payload=$(jq -nc --arg cmd "$command" --arg req "$request_id" \
    '{cmd: $cmd, request_id: $req}')

  _ocap_nats_pub "$subject" "$payload"
  echo "Message sent: $request_id -> $recipient"
}

# Inbox: get this node's identity
# For captains, uses ship_id from identity file for NATS addressing
# For commodore, uses hostname
_ocap_inbox_identity() {
  local role ship_id hostname
  role=$(_ocap_get_role)

  if [[ "$role" == "captain" ]]; then
    ship_id=$(jq -r '.ship_id // empty' "$OCAP_IDENTITY_FILE" 2>/dev/null)
    if [[ -n "$ship_id" ]]; then
      echo "captain@${ship_id}"
      return
    fi
  fi

  # Fallback to hostname for commodore or if ship_id not set
  hostname=$(hostname -f 2>/dev/null || hostname)
  echo "${role}@${hostname}"
}

# Scheduler: handle command execution
_ocap_scheduler_handle_cmd_exec() {
  local cmd="$1" request_id="$2"

  _ocap_log "Executing: $cmd"

  # Create artifact directory for output
  local artifact_dir exit_code
  artifact_dir="$(_ocap_artifacts_root)/${request_id:-$(_ocap_uuid_gen)}"
  mkdir -p "$artifact_dir"

  # Execute command with timeout, capture output
  set +e
  timeout "$OCAP_CMD_TIMEOUT_S" bash -c "$cmd" > "$artifact_dir/stdout.txt" 2> "$artifact_dir/stderr.txt"
  exit_code=$?
  set -e

  _ocap_log "Command finished: exit=$exit_code, artifacts: $artifact_dir"
}

# ==============================================================================
# SECTION: COMMAND HANDLERS
# Description: Public CLI commands with role-based dispatch
# ==============================================================================

# Command: init - Bootstrap flagship VM
ocap_cmd_init() {
  _ocap_require_role local
  _ocap_need_cmd ssh
  _ocap_need_cmd jq
  _ocap_need_cmd scp

  [[ -f "$OCAP_CONFIG_FILE" ]] && _ocap_die "Already initialized. Config: $OCAP_CONFIG_FILE"

  # Generate unique cluster ID
  local cluster_id flagship_vm
  cluster_id="ocaptain-$(openssl rand -hex 3)"
  flagship_vm="${OCAP_VM_PREFIX_FLAGSHIP}-${cluster_id}"

  # Check for name collision
  local existing_vms
  existing_vms=$(ssh exe.dev ls --json 2>/dev/null | jq -r '.vms[]?.vm_name // empty' || true)
  if echo "$existing_vms" | grep -qx "$flagship_vm"; then
    _ocap_die "VM '$flagship_vm' already exists (name collision). Please retry."
  fi

  # Create VM and get connection info
  local vm_output ssh_dest init_env dotfiles_env
  vm_output=$(_ocap_create_vm "$flagship_vm")
  ssh_dest=$(echo "$vm_output" | sed -n '1p')
  init_env=$(echo "$vm_output" | sed -n '2p')
  dotfiles_env=$(echo "$vm_output" | sed -n '3p')

  # Set up fleet SSH key (flagship-specific)
  _ocap_log "Setting up fleet SSH key..."
  ssh "$ssh_dest" 'ssh-keygen -t ed25519 -N "" -f ~/.ssh/id_ed25519 -q 2>/dev/null || true'
  local flagship_pubkey flagship_privkey
  flagship_pubkey=$(ssh "$ssh_dest" 'cat ~/.ssh/id_ed25519.pub')
  flagship_privkey=$(ssh "$ssh_dest" 'cat ~/.ssh/id_ed25519')

  # shellcheck disable=SC2029  # Intentional client-side expansion
  ssh exe.dev ssh-key add "$flagship_pubkey" \
    || _ocap_log "Warning: Could not add fleet SSH key (may already exist)"
  ssh "$ssh_dest" 'ssh -o StrictHostKeyChecking=accept-new exe.dev whoami >/dev/null 2>&1' || true

  # Store Claude token if provided
  if [[ -n "${CLAUDE_CODE_OAUTH_TOKEN:-}" ]]; then
    _ocap_log "Storing Claude Code token on flagship..."
    # shellcheck disable=SC2029  # Intentional client-side expansion
    ssh "$ssh_dest" "sudo mkdir -p /etc/ocaptain && printf '%s' $(_ocap_shell_quote "$CLAUDE_CODE_OAUTH_TOKEN") | sudo tee /etc/ocaptain/claude_token > /dev/null && sudo chmod 600 /etc/ocaptain/claude_token"
  fi

  # Run commodore init
  _ocap_log "Running commodore init on flagship..."
  # shellcheck disable=SC2029  # Intentional client-side expansion
  ssh "$ssh_dest" "$init_env $dotfiles_env \$HOME/.local/bin/ocaptain _init_commodore"

  # Save local config
  _ocap_log "Saving local config..."
  mkdir -p "$OCAP_CONFIG_DIR"
  local cluster_privkey_b64 cluster_pubkey_b64
  cluster_privkey_b64=$(echo "$flagship_privkey" | base64 | tr -d '\n')
  cluster_pubkey_b64=$(echo "$flagship_pubkey" | base64 | tr -d '\n')

  jq -n \
    --arg flagship "$ssh_dest" \
    --arg flagship_vm "$flagship_vm" \
    --arg cluster_id "$cluster_id" \
    --arg privkey "$cluster_privkey_b64" \
    --arg pubkey "$cluster_pubkey_b64" \
    --arg created "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
    '{flagship: $flagship, flagship_vm: $flagship_vm, cluster_id: $cluster_id,
      cluster_privkey_b64: $privkey, cluster_pubkey_b64: $pubkey, created_at: $created}' \
    > "$OCAP_CONFIG_FILE"

  _ocap_log "Done! Cluster '$cluster_id' ready at: $ssh_dest"
  _ocap_log "Run 'ocaptain fleet status' to verify."
}

# Command: fleet status - Show fleet status
# Args: [--json]
ocap_cmd_fleet_status() {
  local json_flag=""
  [[ "${1:-}" == "--json" ]] && json_flag="--json"

  case "$(_ocap_get_role)" in
    local)
      _ocap_need_flagship
      _ocap_flagship_ssh "\$HOME/.local/bin/ocaptain fleet status $json_flag"
      ;;
    commodore)
      _ocap_fleet_status_impl $json_flag
      ;;
    captain)
      _ocap_die "Fleet status not available from ships"
      ;;
  esac
}

# Command: fleet sink - Destroy ships (and optionally flagship)
ocap_cmd_fleet_sink() {
  local force=false scuttle=false
  for arg in "$@"; do
    case "$arg" in
      --force) force=true ;;
      --scuttle) scuttle=true ;;
    esac
  done

  _ocap_fleet_sink_direct "$force" "$scuttle"
}

# Command: ship create - Create a new ship
ocap_cmd_ship_create() {
  local arg="$1"
  [[ -n "$arg" ]] || _ocap_die "Usage: ocaptain ship create <owner/repo | name>"

  # Only require GH_TOKEN if creating a ship with a repo
  if [[ "$arg" == */* && -z "${GH_TOKEN:-}" ]]; then
    _ocap_die "GH_TOKEN env var required when creating a ship with a repo"
  fi

  case "$(_ocap_get_role)" in
    local)
      _ocap_need_flagship
      _ocap_log "Creating ship '$arg' (via flagship)..."
      local init_env dotfiles_env
      init_env=$(_ocap_upload_init_script "$(_ocap_flagship)")
      dotfiles_env=$(_ocap_upload_dotfiles "$(_ocap_flagship)")
      local gh_token_env=""
      [[ -n "${GH_TOKEN:-}" ]] && gh_token_env="GH_TOKEN=$(printf %q "$GH_TOKEN")"
      _ocap_flagship_ssh "$gh_token_env $init_env $dotfiles_env \$HOME/.local/bin/ocaptain ship create $(printf %q "$arg")"
      ;;
    commodore)
      _ocap_ship_create_impl "$arg"
      ;;
    captain)
      _ocap_die "Cannot create ships from a ship"
      ;;
  esac
}

# Command: ship destroy - Destroy a ship
ocap_cmd_ship_destroy() {
  local prefix="$1"
  [[ -n "$prefix" ]] || _ocap_die "Usage: ocaptain ship destroy <prefix>"

  case "$(_ocap_get_role)" in
    local)
      _ocap_need_flagship
      _ocap_log "Destroying ship matching '$prefix' (via flagship)..."
      _ocap_flagship_ssh "\$HOME/.local/bin/ocaptain ship destroy $(printf %q "$prefix")"
      ;;
    commodore)
      _ocap_ship_destroy_impl "$prefix"
      ;;
    captain)
      _ocap_die "Cannot destroy ships from a ship"
      ;;
  esac
}

# Command: ship ssh - SSH into a ship
ocap_cmd_ship_ssh() {
  local prefix="$1"
  [[ -n "$prefix" ]] || _ocap_die "Usage: ocaptain ship ssh <prefix>"

  case "$(_ocap_get_role)" in
    local)
      _ocap_need_flagship
      # Delegate to flagship's resolver
      local result
      result=$(_ocap_flagship_ssh "\$HOME/.local/bin/ocaptain _ship_resolve $(_ocap_shell_quote "$prefix")") \
        || _ocap_die "No ship matches '$prefix'"
      exec ssh -o StrictHostKeyChecking=accept-new "$result"
      ;;
    commodore)
      local dest
      dest=$(_ocap_ship_resolve "$prefix")
      exec ssh -o StrictHostKeyChecking=accept-new "$dest"
      ;;
    captain)
      _ocap_die "Cannot SSH to ships from a ship"
      ;;
  esac
}

# Command: inbox - Messaging commands
ocap_cmd_inbox() {
  _ocap_require_role commodore captain

  local subcmd="${1:-}"
  shift || true

  case "$subcmd" in
    send) _ocap_inbox_send "$@" ;;
    identity) _ocap_inbox_identity ;;
    *) _ocap_die "Usage: ocaptain inbox [send|identity]" ;;
  esac
}

# Internal command: _init_commodore - Initialize flagship identity
ocap_cmd__init_commodore() {
  _ocap_log "Initializing commodore identity..."
  mkdir -p "$OCAP_CONFIG_DIR"
  jq -n '{role: "commodore"}' > "$OCAP_IDENTITY_FILE"
  jq -n '{flagship: "localhost"}' > "$OCAP_CONFIG_FILE"

  _ocap_run_init_script commodore

  _ocap_log "Initializing ships registry..."
  _ocap_init_ships_registry

  _ocap_log "Commodore initialized."
}

# Internal command: _init_captain - Initialize ship identity
ocap_cmd__init_captain() {
  local repo="${1:-}"

  _ocap_log "Initializing captain identity..."
  mkdir -p "$OCAP_CONFIG_DIR"
  # Store ship_id in identity for NATS subject addressing
  jq -n --arg ship_id "${SHIP_ID:-}" \
    '{role: "captain", ship_id: (if $ship_id == "" then null else $ship_id end)}' > "$OCAP_IDENTITY_FILE"
  jq -n --arg flagship "${FLAGSHIP_SSH_DEST:-}" \
    'if $flagship == "" then {flagship: null} else {flagship: $flagship} end' > "$OCAP_CONFIG_FILE"

  _ocap_run_init_script captain \
    "TARGET_REPO=$repo" \
    "SHIP_SSH_PRIVKEY_B64=${SHIP_SSH_PRIVKEY_B64:-}" \
    "SHIP_SSH_PUBKEY_B64=${SHIP_SSH_PUBKEY_B64:-}"

  _ocap_log "Captain initialized${repo:+ for $repo}."
}

# Internal command: _ship_resolve - Resolve ship prefix to ssh_dest
ocap_cmd__ship_resolve() {
  _ocap_ship_resolve "$@"
}

# Internal command: _scheduler - Run the NATS message scheduler
ocap_cmd__scheduler() {
  _ocap_require_role commodore captain

  local my_identity my_role subject
  my_identity=$(_ocap_inbox_identity)
  [[ -n "$my_identity" ]] || _ocap_die "No identity configured"

  # Determine subscription subject based on role
  my_role="${my_identity%%@*}"
  if [[ "$my_role" == "commodore" ]]; then
    subject="ocap.cmd.commodore"
  else
    # Extract ship ID from identity (e.g., "captain@ship-abc123" -> "ship-abc123")
    subject="ocap.cmd.${my_identity#*@}"
  fi

  trap '_ocap_log "Scheduler shutting down"; exit 0' SIGTERM SIGINT

  _ocap_log "NATS scheduler starting for $my_identity (subject: $subject)"

  # Subscribe to NATS subject and process messages
  _ocap_nats_sub "$subject" | while IFS= read -r msg; do
    [[ -n "$msg" ]] || continue

    local cmd request_id
    cmd=$(echo "$msg" | jq -r '.cmd // empty')
    request_id=$(echo "$msg" | jq -r '.request_id // empty')

    [[ -n "$cmd" ]] || { _ocap_log "Empty or invalid command in message, skipping"; continue; }

    _ocap_scheduler_handle_cmd_exec "$cmd" "$request_id"
  done
}

# Command: help - Show usage information
ocap_cmd_help() {
  cat <<HELP
ocaptain v${OCAP_VERSION} - lightweight multi-agent control plane

USAGE:
  ocaptain init                         Bootstrap flagship VM
  ocaptain fleet status [--json]        Show fleet status
  ocaptain fleet sink [--force] [--scuttle]  Destroy ships
    --scuttle  Also destroy flagship
  ocaptain ship create <owner/repo|name> Create ship (repo or empty)
  ocaptain ship destroy <name>          Destroy a ship
  ocaptain ship ssh <name>              SSH into a ship
  ocaptain inbox send <rcpt> <cmd>      Send command (captain@<ship-id> or commodore@flagship)
  ocaptain inbox identity               Show this node's identity

HELP
}

# ==============================================================================
# SECTION: MAIN DISPATCHER
# Description: Entry point and command routing
# ==============================================================================

ocap_main() {
  # When sourced for testing, don't execute - just expose functions
  [[ "$OCAP_SOURCED" == "true" ]] && return 0

  case "${1:-help}" in
    -h|--help|help) ocap_cmd_help ;;
    init) ocap_cmd_init ;;
    fleet)
      case "${2:-}" in
        status) ocap_cmd_fleet_status "${3:-}" ;;
        sink|destroy) shift 2; ocap_cmd_fleet_sink "$@" ;;
        *) _ocap_die "Usage: ocaptain fleet [status|sink|destroy]" ;;
      esac ;;
    ship)
      case "${2:-}" in
        create) ocap_cmd_ship_create "${3:-}" ;;
        destroy) ocap_cmd_ship_destroy "${3:-}" ;;
        ssh) ocap_cmd_ship_ssh "${3:-}" ;;
        *) _ocap_die "Usage: ocaptain ship [create|destroy|ssh] <arg>" ;;
      esac ;;
    inbox) shift; ocap_cmd_inbox "$@" ;;
    _init_commodore) ocap_cmd__init_commodore ;;
    _init_captain) ocap_cmd__init_captain "${2:-}" ;;
    _ship_resolve) ocap_cmd__ship_resolve "${2:-}" ;;
    _scheduler) ocap_cmd__scheduler ;;
    *) _ocap_die "Unknown command: $1. Run 'ocaptain help' for usage." ;;
  esac
}

# Execute main when run directly (not sourced)
ocap_main "$@"
